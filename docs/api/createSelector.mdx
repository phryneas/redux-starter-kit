---
id: createSelector
title: createSelector
sidebar_label: createSelector
hide_title: true
---

# `createSelector`

The `createSelector` utility from the [Reselect library](https://github.com/reduxjs/reselect), re-exported for ease of use.

For more details on using `createSelector`, see:

- The [Reselect API documentation](https://github.com/reduxjs/reselect)
- [React-Redux docs: Hooks API - Using memoizing selectors](https://react-redux.js.org/next/api/hooks#using-memoizing-selectors)
- [Idiomatic Redux: Using Reselect Selectors for Encapsulation and Performance](https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/)
- [React/Redux Links: Reducers and Selectors](https://github.com/markerikson/react-redux-links/blob/master/redux-reducers-selectors.md)

> **Note**: Prior to v0.7, RTK re-exported `createSelector` from [`selectorator`](https://github.com/planttheidea/selectorator), which
> allowed using string keypaths as input selectors. This was removed, as it ultimately did not provide enough benefits, and
> the string keypaths made static typing for selectors difficult.

# `createDraftSafeSelector`

Besides re-exporting `createSelector`, RTK also exports a wrapped version of `createSelector` named `createDraftSafeSelector` that allows you to create selectors that
can be used in the context of `createReducer` and `createSlice` reducers with mutable logic.

So assume the following code:

```js
const selectSelf = (state: State) => state
const unsafeSelector = createSelector(selectSelf, state => state.value)
const draftSafeSelector = createDraftSafeSelector(
  selectSelf,
  state => state.value
)

// in your reducer:

state.value = 1

const unsafe1 = unsafeSelector(state)
const safe1 = draftSafeSelector(state)

state.value = 2

const unsafe2 = unsafeSelector(state)
const safe2 = draftSafeSelector(state)
```

After executing that, `unsafe1` and `unsafe2` will be of the same value, because the memoized selector was
executed on the same object - but `safe2` will actually be different from `safe1` (with the updated value of `2`),
because the safe selector detected that it was executed on a `immer` draft object and recalculated using the current
value instead of returning a cached value.

When used with plain state values, the selector will still memoize normally based on the inputs.  But, when used with Immer draft values, the selector will err on the side of recalculating the results, just to be safe.
err on the side of recalculating, just to be safe.

All selectors created by `entityAdapter.getSelectors` will be such "draft safe" selectors by default.
